<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.17"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <title>=nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library: nil::crypto3 Namespace Reference</title>
    <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="../../dynsections.js"></script>
    <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
    <link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../../bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <!-- SmartMenus jQuery Plugin -->
    <script type="text/javascript" src="../../jquery.smartmenus.js"></script>
    <!-- SmartMenus jQuery Bootstrap Addon -->
    <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.js"></script>
    <!-- highlight.js Syntax Highlighter -->
    <link rel="stylesheet" href="../../darkula.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.16.2/build/highlight.min.js"></script>
    <!--    <script>-->
    <!--        $(function () {-->
    <!--            $(".fragment").each(function (i, node) {-->
    <!--                var $node = $(node);-->
    <!--                $node.html("<pre><code class='" +-->
    <!--                    $node.attr("class") + "'>" +-->
    <!--                    $node.text() + "</code></pre>");-->
    <!--                hljs.highlightBlock(node);-->
    <!--            });-->
    <!--        });-->
    <!--    </script>-->
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand">=nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library 0.3.0</a>
        </div>
    </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div class="content" id="content">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                    <div style="margin-bottom: 15px;">
                        <!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/d2d/namespacenil.html">nil</a></li><li class="navelem"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html">crypto3</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nil::crypto3 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:dc/ddf/namespacenil_1_1crypto3_1_1accumulators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/ddf/namespacenil_1_1crypto3_1_1accumulators.html">accumulators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d4f/namespacenil_1_1crypto3_1_1adaptors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d4f/namespacenil_1_1crypto3_1_1adaptors.html">adaptors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d38/namespacenil_1_1crypto3_1_1block"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d38/namespacenil_1_1crypto3_1_1block.html">block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d1d/namespacenil_1_1crypto3_1_1codec"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d1d/namespacenil_1_1crypto3_1_1codec.html">codec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:de/df4/namespacenil_1_1crypto3_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/df4/namespacenil_1_1crypto3_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d50/namespacenil_1_1crypto3_1_1hash"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d50/namespacenil_1_1crypto3_1_1hash.html">hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d4/d35/namespacenil_1_1crypto3_1_1kdf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d35/namespacenil_1_1crypto3_1_1kdf.html">kdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/dc5/namespacenil_1_1crypto3_1_1mac"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc5/namespacenil_1_1crypto3_1_1mac.html">mac</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d41/namespacenil_1_1crypto3_1_1stream"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d41/namespacenil_1_1crypto3_1_1stream.html">stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:da/d8f/namespacenil_1_1crypto3_1_1stream__endian"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/namespacenil_1_1crypto3_1_1stream__endian.html">stream_endian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d39/namespacenil_1_1crypto3_1_1vdf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d39/namespacenil_1_1crypto3_1_1vdf.html">vdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1c/classnil_1_1crypto3_1_1cpuid.html">cpuid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d0e/classnil_1_1crypto3_1_1memory__pool.html">memory_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d60/classnil_1_1crypto3_1_1mlock__allocator.html">mlock_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa1339a9fee50ef8fd7e95830e49c2d1c"><td class="memTemplParams" colspan="2">template&lt;std::size_t DigestBits&gt; </td></tr>
<tr class="memitem:aa1339a9fee50ef8fd7e95830e49c2d1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a> = boost::container::small_vector&lt; <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, DigestBits/octet_bits &gt;</td></tr>
<tr class="separator:aa1339a9fee50ef8fd7e95830e49c2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0503e99e29f676db5e56ef403ff04d17"><td class="memItemLeft" align="right" valign="top">typedef boost::uint_t&lt; octet_bits &gt;::least&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a></td></tr>
<tr class="separator:a0503e99e29f676db5e56ef403ff04d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc9a48566e004d40f7a525952bbb363"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbc9a48566e004d40f7a525952bbb363"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#afbc9a48566e004d40f7a525952bbb363">secure_deque</a> = std::deque&lt; T, <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:afbc9a48566e004d40f7a525952bbb363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a1d69e697fe5dc5f150bcfa0358862"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05a1d69e697fe5dc5f150bcfa0358862"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a05a1d69e697fe5dc5f150bcfa0358862">secure_vector</a> = std::vector&lt; T, <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a05a1d69e697fe5dc5f150bcfa0358862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad67ac363b854f5164cdc1ff1ae364bdf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad67ac363b854f5164cdc1ff1ae364bdf">allocate_locked_pages</a> (size_t length)</td></tr>
<tr class="separator:ad67ac363b854f5164cdc1ff1ae364bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ee1d8b012f9a9aee77e495fc507fd8"><td class="memItemLeft" align="right" valign="top">CRYPTO3_MALLOC_FN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af9ee1d8b012f9a9aee77e495fc507fd8">allocate_memory</a> (size_t elems, size_t elem_size)</td></tr>
<tr class="separator:af9ee1d8b012f9a9aee77e495fc507fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaba2bf1d1bc97583c0e4b9b584916e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aceaba2bf1d1bc97583c0e4b9b584916e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aceaba2bf1d1bc97583c0e4b9b584916e">bswap_4</a> (T x[4])</td></tr>
<tr class="separator:aceaba2bf1d1bc97583c0e4b9b584916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8350641ae0dac5d8006cc79082f7d446"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a8350641ae0dac5d8006cc79082f7d446"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a8350641ae0dac5d8006cc79082f7d446">buffer_insert</a> (std::vector&lt; T, Alloc &gt; &amp;buf, size_t buf_offset, const std::vector&lt; T, Alloc2 &gt; &amp;input)</td></tr>
<tr class="separator:a8350641ae0dac5d8006cc79082f7d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3963efe053611f9acc1c08c5081429b4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a3963efe053611f9acc1c08c5081429b4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a3963efe053611f9acc1c08c5081429b4">buffer_insert</a> (std::vector&lt; T, Alloc &gt; &amp;buf, size_t buf_offset, const T input[], size_t input_length)</td></tr>
<tr class="separator:a3963efe053611f9acc1c08c5081429b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a5fd7ee0ee51b570b16d0901f30947"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af5a5fd7ee0ee51b570b16d0901f30947">cast_char_ptr_to_uint8</a> (char *s)</td></tr>
<tr class="separator:af5a5fd7ee0ee51b570b16d0901f30947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105237964a746086e39a6d57c3b30fba"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a105237964a746086e39a6d57c3b30fba">cast_char_ptr_to_uint8</a> (const char *s)</td></tr>
<tr class="separator:a105237964a746086e39a6d57c3b30fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae888a507bc7a9409eff9ab6a7323162a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ae888a507bc7a9409eff9ab6a7323162a">cast_uint8_ptr_to_char</a> (const uint8_t *b)</td></tr>
<tr class="separator:ae888a507bc7a9409eff9ab6a7323162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06383f87da474f094510c35f5c28eaa1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a06383f87da474f094510c35f5c28eaa1">cast_uint8_ptr_to_char</a> (uint8_t *b)</td></tr>
<tr class="separator:a06383f87da474f094510c35f5c28eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937392c8a0bcc966ede0e8e88d54e0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a937392c8a0bcc966ede0e8e88d54e0df">clear_bytes</a> (void *ptr, size_t bytes)</td></tr>
<tr class="separator:a937392c8a0bcc966ede0e8e88d54e0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc9ecd704d764c05e25c8d3f5219536"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebc9ecd704d764c05e25c8d3f5219536"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aebc9ecd704d764c05e25c8d3f5219536">clear_mem</a> (T *ptr, size_t n)</td></tr>
<tr class="separator:aebc9ecd704d764c05e25c8d3f5219536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdebb8ac8de97d40e3a8fa42cd0844a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#abbdebb8ac8de97d40e3a8fa42cd0844a">constant_time_compare</a> (const uint8_t x[], const uint8_t y[], size_t len)</td></tr>
<tr class="separator:abbdebb8ac8de97d40e3a8fa42cd0844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70ff4d0dfd1067496b47450d80e6ae3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad70ff4d0dfd1067496b47450d80e6ae3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad70ff4d0dfd1067496b47450d80e6ae3">copy_mem</a> (T *out, const T *in, size_t n)</td></tr>
<tr class="separator:ad70ff4d0dfd1067496b47450d80e6ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7412e5a3015574031af2fd1cb98f2027"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a7412e5a3015574031af2fd1cb98f2027">deallocate_memory</a> (void *p, size_t elems, size_t elem_size)</td></tr>
<tr class="separator:a7412e5a3015574031af2fd1cb98f2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd92f786fc08579a54dc35dd53473f8"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaddd92f786fc08579a54dc35dd53473f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaddd92f786fc08579a54dc35dd53473f8">decode</a> (const SinglePassRange &amp;r)</td></tr>
<tr class="memdesc:gaddd92f786fc08579a54dc35dd53473f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaddd92f786fc08579a54dc35dd53473f8">More...</a><br /></td></tr>
<tr class="separator:gaddd92f786fc08579a54dc35dd53473f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga3bfad0676c2297534c4b6a2fc81b14f7">decode</a> (const SinglePassRange &amp;rng, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga3bfad0676c2297534c4b6a2fc81b14f7">More...</a><br /></td></tr>
<tr class="separator:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ac12764148d33976f1f5633ba3e4e"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga029ac12764148d33976f1f5633ba3e4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga029ac12764148d33976f1f5633ba3e4e">decode</a> (const SinglePassRange &amp;rng, OutputIterator out)</td></tr>
<tr class="memdesc:ga029ac12764148d33976f1f5633ba3e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga029ac12764148d33976f1f5633ba3e4e">More...</a><br /></td></tr>
<tr class="separator:ga029ac12764148d33976f1f5633ba3e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga9b380b63793f8b569d9b993763ddfe2a">decode</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ga9b380b63793f8b569d9b993763ddfe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#ga9b380b63793f8b569d9b993763ddfe2a">More...</a><br /></td></tr>
<tr class="separator:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga10ff91e4a363478d87dc7744dc1f3756">decode</a> (InputIterator first, InputIterator last, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga10ff91e4a363478d87dc7744dc1f3756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga10ff91e4a363478d87dc7744dc1f3756">More...</a><br /></td></tr>
<tr class="separator:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05c728507aab1602959b4975b09764"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gafd05c728507aab1602959b4975b09764"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gafd05c728507aab1602959b4975b09764">decode</a> (InputIterator first, InputIterator last, OutputIterator out)</td></tr>
<tr class="memdesc:gafd05c728507aab1602959b4975b09764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last), and inserts the result to another range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gafd05c728507aab1602959b4975b09764">More...</a><br /></td></tr>
<tr class="separator:gafd05c728507aab1602959b4975b09764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f16ab00e2d0481d38ff60ea6607217e"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename KeyRange , typename CipherAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga9f16ab00e2d0481d38ff60ea6607217e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc9/structnil_1_1crypto3_1_1block_1_1detail_1_1range__cipher__impl.html">block::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/df4/structnil_1_1crypto3_1_1block_1_1detail_1_1value__cipher__impl.html">block::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#ga9f16ab00e2d0481d38ff60ea6607217e">decrypt</a> (const SinglePassRange &amp;r, const KeyRange &amp;key)</td></tr>
<tr class="separator:ga9f16ab00e2d0481d38ff60ea6607217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e2f741ce977312e483546d5fa772f64"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename SinglePassRange , typename KeyRange , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga4e2f741ce977312e483546d5fa772f64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga4e2f741ce977312e483546d5fa772f64">decrypt</a> (const SinglePassRange &amp;r, const KeyRange &amp;key)</td></tr>
<tr class="separator:ga4e2f741ce977312e483546d5fa772f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c662eb4315eccbc4a6a6995bc2fb2"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename OutputAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gad15c662eb4315eccbc4a6a6995bc2fb2"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gad15c662eb4315eccbc4a6a6995bc2fb2">decrypt</a> (const SinglePassRange &amp;r, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:gad15c662eb4315eccbc4a6a6995bc2fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99c00e4fdb0060deb15497ca1302ea9"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename KeyRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gae99c00e4fdb0060deb15497ca1302ea9"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gae99c00e4fdb0060deb15497ca1302ea9">decrypt</a> (const SinglePassRange &amp;rng, const KeyRange &amp;key, OutputIterator out)</td></tr>
<tr class="separator:gae99c00e4fdb0060deb15497ca1302ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91ffcb5396e1e31bca3fd3e8d1b4d8c"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename KeyIterator , typename CipherAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gac91ffcb5396e1e31bca3fd3e8d1b4d8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc9/structnil_1_1crypto3_1_1block_1_1detail_1_1range__cipher__impl.html">block::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/df4/structnil_1_1crypto3_1_1block_1_1detail_1_1value__cipher__impl.html">block::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gac91ffcb5396e1e31bca3fd3e8d1b4d8c">decrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last)</td></tr>
<tr class="separator:gac91ffcb5396e1e31bca3fd3e8d1b4d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cdeab2d881ad73243032b7f8192e8b0"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename InputIterator , typename KeyIterator , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga1cdeab2d881ad73243032b7f8192e8b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga1cdeab2d881ad73243032b7f8192e8b0">decrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last)</td></tr>
<tr class="separator:ga1cdeab2d881ad73243032b7f8192e8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34eb918a7d663cd8e26d40ea082e8091"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename KeyIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga34eb918a7d663cd8e26d40ea082e8091"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#ga34eb918a7d663cd8e26d40ea082e8091">decrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last, OutputIterator out)</td></tr>
<tr class="separator:ga34eb918a7d663cd8e26d40ea082e8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2213f52c7711927637e957ed5db8941"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename OutputAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_decrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gad2213f52c7711927637e957ed5db8941"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gad2213f52c7711927637e957ed5db8941">decrypt</a> (InputIterator first, InputIterator last, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:gad2213f52c7711927637e957ed5db8941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaa731755d2bec7fd2dc9c33f5648b8a5c">encode</a> (const SinglePassRange &amp;r)</td></tr>
<tr class="memdesc:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaa731755d2bec7fd2dc9c33f5648b8a5c">More...</a><br /></td></tr>
<tr class="separator:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753e9fac08375391143e153b68cc86cd"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga753e9fac08375391143e153b68cc86cd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga753e9fac08375391143e153b68cc86cd">encode</a> (const SinglePassRange &amp;rng, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga753e9fac08375391143e153b68cc86cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga753e9fac08375391143e153b68cc86cd">More...</a><br /></td></tr>
<tr class="separator:ga753e9fac08375391143e153b68cc86cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gadc52aa495b9ffc48fa969d4059eb2229">encode</a> (const SinglePassRange &amp;rng, OutputIterator out)</td></tr>
<tr class="memdesc:gadc52aa495b9ffc48fa969d4059eb2229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gadc52aa495b9ffc48fa969d4059eb2229">More...</a><br /></td></tr>
<tr class="separator:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaca6eac88a0bbb2b6965918a491540eb4">encode</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:gaca6eac88a0bbb2b6965918a491540eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaca6eac88a0bbb2b6965918a491540eb4">More...</a><br /></td></tr>
<tr class="separator:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e74d24b6641215095b9c8409c99361"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaa4e74d24b6641215095b9c8409c99361"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaa4e74d24b6641215095b9c8409c99361">encode</a> (InputIterator first, InputIterator last, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:gaa4e74d24b6641215095b9c8409c99361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with type satisfying AccumulatorSet requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaa4e74d24b6641215095b9c8409c99361">More...</a><br /></td></tr>
<tr class="separator:gaa4e74d24b6641215095b9c8409c99361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gad8327c5f73064ccefe2f1bbc7abe5e9e">encode</a> (InputIterator first, InputIterator last, OutputIterator out)</td></tr>
<tr class="memdesc:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last), and inserts the result to another range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gad8327c5f73064ccefe2f1bbc7abe5e9e">More...</a><br /></td></tr>
<tr class="separator:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9772ce5b0de37001d3442fc173ecd0b1"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename KeyRange , typename CipherAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga9772ce5b0de37001d3442fc173ecd0b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc9/structnil_1_1crypto3_1_1block_1_1detail_1_1range__cipher__impl.html">block::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/df4/structnil_1_1crypto3_1_1block_1_1detail_1_1value__cipher__impl.html">block::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#ga9772ce5b0de37001d3442fc173ecd0b1">encrypt</a> (const SinglePassRange &amp;r, const KeyRange &amp;key)</td></tr>
<tr class="separator:ga9772ce5b0de37001d3442fc173ecd0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3966867d094cee85d62578d5aa2844"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename SinglePassRange , typename KeyRange , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga3c3966867d094cee85d62578d5aa2844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga3c3966867d094cee85d62578d5aa2844">encrypt</a> (const SinglePassRange &amp;r, const KeyRange &amp;key)</td></tr>
<tr class="separator:ga3c3966867d094cee85d62578d5aa2844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd932020e33a733b6df4438b42d4bfd"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename OutputAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gafdd932020e33a733b6df4438b42d4bfd"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gafdd932020e33a733b6df4438b42d4bfd">encrypt</a> (const SinglePassRange &amp;r, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:gafdd932020e33a733b6df4438b42d4bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69f965b7b5c7df1950e6f71a0e7013c"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename SinglePassRange , typename KeyRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad69f965b7b5c7df1950e6f71a0e7013c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gad69f965b7b5c7df1950e6f71a0e7013c">encrypt</a> (const SinglePassRange &amp;rng, const KeyRange &amp;key, OutputIterator out)</td></tr>
<tr class="separator:gad69f965b7b5c7df1950e6f71a0e7013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb3f64a796242a54efc0feae4ad6790"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename KeyIterator , typename CipherAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gaeeb3f64a796242a54efc0feae4ad6790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d3/dc9/structnil_1_1crypto3_1_1block_1_1detail_1_1range__cipher__impl.html">block::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/df4/structnil_1_1crypto3_1_1block_1_1detail_1_1value__cipher__impl.html">block::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gaeeb3f64a796242a54efc0feae4ad6790">encrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last)</td></tr>
<tr class="separator:gaeeb3f64a796242a54efc0feae4ad6790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97789c4ad33b6860fc8cc0e306f84efa"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename InputIterator , typename KeyIterator , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga97789c4ad33b6860fc8cc0e306f84efa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga97789c4ad33b6860fc8cc0e306f84efa">encrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last)</td></tr>
<tr class="separator:ga97789c4ad33b6860fc8cc0e306f84efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae990426597e776b91d77ab08e0b91e"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename KeyIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaaae990426597e776b91d77ab08e0b91e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#gaaae990426597e776b91d77ab08e0b91e">encrypt</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last, OutputIterator out)</td></tr>
<tr class="separator:gaaae990426597e776b91d77ab08e0b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga848decffeacc448138f47f6ffab96ce6"><td class="memTemplParams" colspan="2">template&lt;typename BlockCipher , typename InputIterator , typename OutputAccumulator  = typename block::accumulator_set&lt;typename BlockCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga848decffeacc448138f47f6ffab96ce6"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dab/group__block__algorithms.html#ga848decffeacc448138f47f6ffab96ce6">encrypt</a> (InputIterator first, InputIterator last, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:ga848decffeacc448138f47f6ffab96ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d74ab736058fa28aff4b9b2b283ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a26d74ab736058fa28aff4b9b2b283ff5">free_locked_pages</a> (void *ptr, size_t length)</td></tr>
<tr class="separator:a26d74ab736058fa28aff4b9b2b283ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8f97dbe038592a7326a8ae794943d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2e8f97dbe038592a7326a8ae794943d8">gcm_multiply_ssse3</a> (uint8_t x[16], const uint64_t HM[256], const uint8_t input[], size_t blocks)</td></tr>
<tr class="separator:a2e8f97dbe038592a7326a8ae794943d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21742d87e3298ca4c04746bb8efff57d"><td class="memItemLeft" align="right" valign="top">uint64_t CRYPTO3_TEST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a21742d87e3298ca4c04746bb8efff57d">get_high_resolution_clock</a> ()</td></tr>
<tr class="separator:a21742d87e3298ca4c04746bb8efff57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace19955c4ae91c8be89c1c57116853d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aace19955c4ae91c8be89c1c57116853d">get_memory_locking_limit</a> ()</td></tr>
<tr class="separator:aace19955c4ae91c8be89c1c57116853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5b2a5393e6c9f3fa2c7a66a464c496"><td class="memItemLeft" align="right" valign="top">uint32_t CRYPTO3_TEST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a8b5b2a5393e6c9f3fa2c7a66a464c496">get_process_id</a> ()</td></tr>
<tr class="separator:a8b5b2a5393e6c9f3fa2c7a66a464c496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebb68a60534ac9243af868678b2fab1"><td class="memItemLeft" align="right" valign="top">uint64_t CRYPTO3_TEST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2ebb68a60534ac9243af868678b2fab1">get_processor_timestamp</a> ()</td></tr>
<tr class="separator:a2ebb68a60534ac9243af868678b2fab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1ded8fdf6173ce53a51f90d00ddd6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a8eb1ded8fdf6173ce53a51f90d00ddd6">get_system_timestamp_ns</a> ()</td></tr>
<tr class="separator:a8eb1ded8fdf6173ce53a51f90d00ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845e6cc9dfa5727d5a7ae03c18268587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a845e6cc9dfa5727d5a7ae03c18268587">initialize_allocator</a> ()</td></tr>
<tr class="separator:a845e6cc9dfa5727d5a7ae03c18268587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be7a1b17ec76efbe55194857dfb173"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38be7a1b17ec76efbe55194857dfb173"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a38be7a1b17ec76efbe55194857dfb173">load_be</a> (const uint8_t in[], std::size_t off=0)</td></tr>
<tr class="separator:a38be7a1b17ec76efbe55194857dfb173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525fb18e9ffe2b22b263778fad0ea026"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a525fb18e9ffe2b22b263778fad0ea026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a525fb18e9ffe2b22b263778fad0ea026">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1)</td></tr>
<tr class="separator:a525fb18e9ffe2b22b263778fad0ea026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6616c4d96004335321c9df387edad23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6616c4d96004335321c9df387edad23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad6616c4d96004335321c9df387edad23">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3)</td></tr>
<tr class="separator:ad6616c4d96004335321c9df387edad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511bb2256a079d512ef170882f6e6997"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a511bb2256a079d512ef170882f6e6997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a511bb2256a079d512ef170882f6e6997">load_be</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3, T &amp;x4, T &amp;x5, T &amp;x6, T &amp;x7)</td></tr>
<tr class="separator:a511bb2256a079d512ef170882f6e6997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8852c501b4993c81a7c3bcc8456a46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b8852c501b4993c81a7c3bcc8456a46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a9b8852c501b4993c81a7c3bcc8456a46">load_be</a> (T out[], const uint8_t in[], size_t count)</td></tr>
<tr class="separator:a9b8852c501b4993c81a7c3bcc8456a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa849feff6fc18f946268b5fa03239e4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aaa849feff6fc18f946268b5fa03239e4"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aaa849feff6fc18f946268b5fa03239e4">load_be&lt; uint16_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:aaa849feff6fc18f946268b5fa03239e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae26a36e78ba432dc653e728b16772d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afae26a36e78ba432dc653e728b16772d"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#afae26a36e78ba432dc653e728b16772d">load_be&lt; uint32_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:afae26a36e78ba432dc653e728b16772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf744ffa3246c8511fc423b4753e597"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afbf744ffa3246c8511fc423b4753e597"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#afbf744ffa3246c8511fc423b4753e597">load_be&lt; uint64_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:afbf744ffa3246c8511fc423b4753e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492c34cc071c3bdc388dfd2b16f20f9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a492c34cc071c3bdc388dfd2b16f20f9d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a492c34cc071c3bdc388dfd2b16f20f9d">load_le</a> (const uint8_t in[], std::size_t off=0)</td></tr>
<tr class="separator:a492c34cc071c3bdc388dfd2b16f20f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4acdd73a613030cc33078e14788c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ac4acdd73a613030cc33078e14788c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2ac4acdd73a613030cc33078e14788c1">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1)</td></tr>
<tr class="separator:a2ac4acdd73a613030cc33078e14788c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee66028e24ca6e3f8bc310ced3061e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0aee66028e24ca6e3f8bc310ced3061e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0aee66028e24ca6e3f8bc310ced3061e">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3)</td></tr>
<tr class="separator:a0aee66028e24ca6e3f8bc310ced3061e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7a14cf694d7fbe480370b4290302f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30c7a14cf694d7fbe480370b4290302f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a30c7a14cf694d7fbe480370b4290302f">load_le</a> (const uint8_t in[], T &amp;x0, T &amp;x1, T &amp;x2, T &amp;x3, T &amp;x4, T &amp;x5, T &amp;x6, T &amp;x7)</td></tr>
<tr class="separator:a30c7a14cf694d7fbe480370b4290302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59c79c30e35917703ec8cd1f61aedb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa59c79c30e35917703ec8cd1f61aedb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa59c79c30e35917703ec8cd1f61aedb1">load_le</a> (T out[], const uint8_t in[], size_t count)</td></tr>
<tr class="separator:aa59c79c30e35917703ec8cd1f61aedb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b794fd5fcfc548c2a6f85233784c498"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0b794fd5fcfc548c2a6f85233784c498"><td class="memTemplItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0b794fd5fcfc548c2a6f85233784c498">load_le&lt; uint16_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:a0b794fd5fcfc548c2a6f85233784c498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d51b42fa4c991fdc659d656f4883884"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3d51b42fa4c991fdc659d656f4883884"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a3d51b42fa4c991fdc659d656f4883884">load_le&lt; uint32_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:a3d51b42fa4c991fdc659d656f4883884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d6109b3527bb9c10f023d9cd9881ef"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac5d6109b3527bb9c10f023d9cd9881ef"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ac5d6109b3527bb9c10f023d9cd9881ef">load_le&lt; uint64_t &gt;</a> (const uint8_t in[], std::size_t off)</td></tr>
<tr class="separator:ac5d6109b3527bb9c10f023d9cd9881ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b080e10b40cc35de320d9366ea96290"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:a5b080e10b40cc35de320d9366ea96290"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="../../de/df4/namespacenil_1_1crypto3_1_1detail.html#ad5131c13a1c31af003ac83bf1bea63f2">detail::ValueType</a>&lt; RandomAccessIterator &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a5b080e10b40cc35de320d9366ea96290">make_array</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr class="separator:a5b080e10b40cc35de320d9366ea96290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec50e505271d8d408ec05764b291380c"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB&gt; </td></tr>
<tr class="memitem:aec50e505271d8d408ec05764b291380c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aec50e505271d8d408ec05764b291380c">operator!=</a> (char const *b, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;a)</td></tr>
<tr class="separator:aec50e505271d8d408ec05764b291380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856408b83a196cc2ba71100584c0fadc"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:a856408b83a196cc2ba71100584c0fadc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a856408b83a196cc2ba71100584c0fadc">operator!=</a> (char const *b, <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;a)</td></tr>
<tr class="separator:a856408b83a196cc2ba71100584c0fadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19602fe221bd2fce600a97aeca7bfd0e"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:a19602fe221bd2fce600a97aeca7bfd0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a19602fe221bd2fce600a97aeca7bfd0e">operator!=</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:a19602fe221bd2fce600a97aeca7bfd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453a3243a8cbca962d31dbb31e4daee3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a453a3243a8cbca962d31dbb31e4daee3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a453a3243a8cbca962d31dbb31e4daee3">operator!=</a> (const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a453a3243a8cbca962d31dbb31e4daee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e8f627f2a864c3ddbae288b76fee2f"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB&gt; </td></tr>
<tr class="memitem:aa0e8f627f2a864c3ddbae288b76fee2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa0e8f627f2a864c3ddbae288b76fee2f">operator!=</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;a, char const *b)</td></tr>
<tr class="separator:aa0e8f627f2a864c3ddbae288b76fee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeffedd8ec03595f789e9ce271902936"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:afeffedd8ec03595f789e9ce271902936"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#afeffedd8ec03595f789e9ce271902936">operator!=</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:afeffedd8ec03595f789e9ce271902936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac802c5106106e6f5544222773aa79540"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:ac802c5106106e6f5544222773aa79540"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ac802c5106106e6f5544222773aa79540">operator!=</a> (<a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;a, char const *b)</td></tr>
<tr class="separator:ac802c5106106e6f5544222773aa79540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ee6f5e44fd9558243adf14913704cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename L &gt; </td></tr>
<tr class="memitem:a65ee6f5e44fd9558243adf14913704cf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a65ee6f5e44fd9558243adf14913704cf">operator+=</a> (std::vector&lt; T, Alloc &gt; &amp;out, const std::pair&lt; const T *, L &gt; &amp;in)</td></tr>
<tr class="separator:a65ee6f5e44fd9558243adf14913704cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67c1311e009eaacf2751db1cef06f99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename L &gt; </td></tr>
<tr class="memitem:ad67c1311e009eaacf2751db1cef06f99"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad67c1311e009eaacf2751db1cef06f99">operator+=</a> (std::vector&lt; T, Alloc &gt; &amp;out, const std::pair&lt; T *, L &gt; &amp;in)</td></tr>
<tr class="separator:ad67c1311e009eaacf2751db1cef06f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab298426e1918d6dda83e039062839465"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:ab298426e1918d6dda83e039062839465"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ab298426e1918d6dda83e039062839465">operator+=</a> (std::vector&lt; T, Alloc &gt; &amp;out, const std::vector&lt; T, Alloc2 &gt; &amp;in)</td></tr>
<tr class="separator:ab298426e1918d6dda83e039062839465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eab9ab9c6cd50d8dc9a1162cddf26f2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a1eab9ab9c6cd50d8dc9a1162cddf26f2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a1eab9ab9c6cd50d8dc9a1162cddf26f2">operator+=</a> (std::vector&lt; T, Alloc &gt; &amp;out, T in)</td></tr>
<tr class="separator:a1eab9ab9c6cd50d8dc9a1162cddf26f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34195078240699cb0147892005ffba5a"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:a34195078240699cb0147892005ffba5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a34195078240699cb0147892005ffba5a">operator&lt;</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:a34195078240699cb0147892005ffba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d39b53ac186c14b014eddb95174bca5"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:a3d39b53ac186c14b014eddb95174bca5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a3d39b53ac186c14b014eddb95174bca5">operator&lt;</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:a3d39b53ac186c14b014eddb95174bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3b571726da4a4b6511fda0aad6a0cf"><td class="memTemplParams" colspan="2">template&lt;std::size_t DigestBits&gt; </td></tr>
<tr class="memitem:a2d3b571726da4a4b6511fda0aad6a0cf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2d3b571726da4a4b6511fda0aad6a0cf">operator&lt;&lt;</a> (std::ostream &amp;sink, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DigestBits &gt; &amp;d)</td></tr>
<tr class="separator:a2d3b571726da4a4b6511fda0aad6a0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488334bf4dce5e610badea2bd664cf33"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:a488334bf4dce5e610badea2bd664cf33"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a488334bf4dce5e610badea2bd664cf33">operator&lt;&lt;</a> (std::ostream &amp;sink, <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;d)</td></tr>
<tr class="separator:a488334bf4dce5e610badea2bd664cf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9658785b70dd12cfbfc6c66717d2d1c"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:ab9658785b70dd12cfbfc6c66717d2d1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ab9658785b70dd12cfbfc6c66717d2d1c">operator&lt;=</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:ab9658785b70dd12cfbfc6c66717d2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac743d422b8b359d34a0e3cadbd5278c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:ac743d422b8b359d34a0e3cadbd5278c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ac743d422b8b359d34a0e3cadbd5278c2">operator&lt;=</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:ac743d422b8b359d34a0e3cadbd5278c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02b241c1f81baf6414599e4f4d500d1"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB&gt; </td></tr>
<tr class="memitem:af02b241c1f81baf6414599e4f4d500d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af02b241c1f81baf6414599e4f4d500d1">operator==</a> (char const *b, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;a)</td></tr>
<tr class="separator:af02b241c1f81baf6414599e4f4d500d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54963797f7768b0865b398e0c981155"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:af54963797f7768b0865b398e0c981155"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af54963797f7768b0865b398e0c981155">operator==</a> (char const *b, <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;a)</td></tr>
<tr class="separator:af54963797f7768b0865b398e0c981155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf672ac7a3ef7de2e4dda1051c424593"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:adf672ac7a3ef7de2e4dda1051c424593"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#adf672ac7a3ef7de2e4dda1051c424593">operator==</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:adf672ac7a3ef7de2e4dda1051c424593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b64ed782f62d20cec19b14d7f8bf803"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6b64ed782f62d20cec19b14d7f8bf803"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a6b64ed782f62d20cec19b14d7f8bf803">operator==</a> (const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a6b64ed782f62d20cec19b14d7f8bf803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82f3edb1640350c8498a62efe5532df"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB&gt; </td></tr>
<tr class="memitem:aa82f3edb1640350c8498a62efe5532df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa82f3edb1640350c8498a62efe5532df">operator==</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;a, char const *b)</td></tr>
<tr class="separator:aa82f3edb1640350c8498a62efe5532df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae0c492a3615b931c63f0917f364a8"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:af0ae0c492a3615b931c63f0917f364a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af0ae0c492a3615b931c63f0917f364a8">operator==</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:af0ae0c492a3615b931c63f0917f364a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba4fe0782ab5783b85650ec764511d0"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:acba4fe0782ab5783b85650ec764511d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#acba4fe0782ab5783b85650ec764511d0">operator==</a> (<a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;a, char const *b)</td></tr>
<tr class="separator:acba4fe0782ab5783b85650ec764511d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c23d68dc09b513f802739dc55065a6"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:a32c23d68dc09b513f802739dc55065a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a32c23d68dc09b513f802739dc55065a6">operator&gt;</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:a32c23d68dc09b513f802739dc55065a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2892e849ab867d1b9c0516ce9c7227"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:aaf2892e849ab867d1b9c0516ce9c7227"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aaf2892e849ab867d1b9c0516ce9c7227">operator&gt;</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:aaf2892e849ab867d1b9c0516ce9c7227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d0a9c0c0ab105d354d8a2a076e7d0c"><td class="memTemplParams" colspan="2">template&lt;unsigned DB1, unsigned DB2&gt; </td></tr>
<tr class="memitem:af6d0a9c0c0ab105d354d8a2a076e7d0c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af6d0a9c0c0ab105d354d8a2a076e7d0c">operator&gt;=</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:af6d0a9c0c0ab105d354d8a2a076e7d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c1dd77b136672ca8a1675c10f1156"><td class="memTemplParams" colspan="2">template&lt;std::size_t DB1, std::size_t DB2&gt; </td></tr>
<tr class="memitem:af84c1dd77b136672ca8a1675c10f1156"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#af84c1dd77b136672ca8a1675c10f1156">operator&gt;=</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;a, const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;b)</td></tr>
<tr class="separator:af84c1dd77b136672ca8a1675c10f1156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c662fab3d36e755d5736b3147dd7a0"><td class="memTemplParams" colspan="2">template&lt;unsigned DB&gt; </td></tr>
<tr class="memitem:a13c662fab3d36e755d5736b3147dd7a0"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a13c662fab3d36e755d5736b3147dd7a0">operator&gt;&gt;</a> (std::istream &amp;source, <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; &amp;d)</td></tr>
<tr class="separator:a13c662fab3d36e755d5736b3147dd7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ed5adb0e11e42db7b611572c3eca59"><td class="memTemplParams" colspan="2">template&lt;std::size_t DigestBits&gt; </td></tr>
<tr class="memitem:a68ed5adb0e11e42db7b611572c3eca59"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a68ed5adb0e11e42db7b611572c3eca59">operator&gt;&gt;</a> (std::istream &amp;source, <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DigestBits &gt; &amp;d)</td></tr>
<tr class="separator:a68ed5adb0e11e42db7b611572c3eca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bd2b64f053986f8a03e87c58b6dc64"><td class="memTemplParams" colspan="2">template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:ad2bd2b64f053986f8a03e87c58b6dc64"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad2bd2b64f053986f8a03e87c58b6dc64">operator^=</a> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in)</td></tr>
<tr class="separator:ad2bd2b64f053986f8a03e87c58b6dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11f921a5a437e5587540cec2e19f317"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ae11f921a5a437e5587540cec2e19f317"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ae11f921a5a437e5587540cec2e19f317">poly_double_n</a> (const Container &amp;c)</td></tr>
<tr class="separator:ae11f921a5a437e5587540cec2e19f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c379ab3e28936f5cf8e818814f0c66"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a44c379ab3e28936f5cf8e818814f0c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a44c379ab3e28936f5cf8e818814f0c66">poly_double_n</a> (uint8_t out[], InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a44c379ab3e28936f5cf8e818814f0c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23303c0d13da227018c7dbb51eeddb61"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a23303c0d13da227018c7dbb51eeddb61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a23303c0d13da227018c7dbb51eeddb61">poly_double_n_le</a> (uint8_t out[], InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a23303c0d13da227018c7dbb51eeddb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a5ea0fac2e190691e9899e8be0e48c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ab5a5ea0fac2e190691e9899e8be0e48c">poly_double_supported_size</a> (size_t n)</td></tr>
<tr class="separator:ab5a5ea0fac2e190691e9899e8be0e48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fd11fb22126f4c52151714e7595cfc"><td class="memTemplParams" colspan="2">template&lt;unsigned NewBits, unsigned OldBits&gt; </td></tr>
<tr class="memitem:a26fd11fb22126f4c52151714e7595cfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; NewBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a26fd11fb22126f4c52151714e7595cfc">resize</a> (const boost::container::small_vector&lt; <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, OldBits/octet_bits &gt; &amp;od)</td></tr>
<tr class="separator:a26fd11fb22126f4c52151714e7595cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b208eaeff49aa255733e8efdc2b682"><td class="memTemplParams" colspan="2">template&lt;std::size_t NewBits, std::size_t OldBits&gt; </td></tr>
<tr class="memitem:a01b208eaeff49aa255733e8efdc2b682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; NewBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a01b208eaeff49aa255733e8efdc2b682">resize</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; OldBits &gt; &amp;od)</td></tr>
<tr class="separator:a01b208eaeff49aa255733e8efdc2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c9b88625038d29bb51ccc7af239aa4"><td class="memTemplParams" colspan="2">template&lt;size_t ROT, typename T &gt; </td></tr>
<tr class="memitem:a97c9b88625038d29bb51ccc7af239aa4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a97c9b88625038d29bb51ccc7af239aa4">rotl</a> (T input)</td></tr>
<tr class="separator:a97c9b88625038d29bb51ccc7af239aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff3f74d5539611e2fa13406db81f54d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeff3f74d5539611e2fa13406db81f54d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aeff3f74d5539611e2fa13406db81f54d">rotl_var</a> (T input, size_t rot)</td></tr>
<tr class="separator:aeff3f74d5539611e2fa13406db81f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefed267f1bf68268bf576a862c1ca2e6"><td class="memTemplParams" colspan="2">template&lt;size_t ROT, typename T &gt; </td></tr>
<tr class="memitem:aefed267f1bf68268bf576a862c1ca2e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aefed267f1bf68268bf576a862c1ca2e6">rotr</a> (T input)</td></tr>
<tr class="separator:aefed267f1bf68268bf576a862c1ca2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d04ec1b177afa6d32e7d064ac7f026"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1d04ec1b177afa6d32e7d064ac7f026"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ab1d04ec1b177afa6d32e7d064ac7f026">rotr_var</a> (T input, size_t rot)</td></tr>
<tr class="separator:ab1d04ec1b177afa6d32e7d064ac7f026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311f90015437d1bd9ed31ff946e2a780"><td class="memItemLeft" align="right" valign="top">int CRYPTO3_TEST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a311f90015437d1bd9ed31ff946e2a780">run_cpu_instruction_probe</a> (std::function&lt; int()&gt; probe_fn)</td></tr>
<tr class="separator:a311f90015437d1bd9ed31ff946e2a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d4828af376c542be8d410e932859d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54d4828af376c542be8d410e932859d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a54d4828af376c542be8d410e932859d7">same_mem</a> (const T *p1, const T *p2, size_t n)</td></tr>
<tr class="separator:a54d4828af376c542be8d410e932859d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c33a4538a65259747fa955c3df71b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a34c33a4538a65259747fa955c3df71b4">secure_scrub_memory</a> (void *ptr, size_t n)</td></tr>
<tr class="separator:a34c33a4538a65259747fa955c3df71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga414f75f0d8c025c3e36bd2fa3027db81"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename SinglePassRange , typename KeyRange , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga414f75f0d8c025c3e36bd2fa3027db81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga414f75f0d8c025c3e36bd2fa3027db81">seek</a> (const SinglePassRange &amp;r, const KeyRange &amp;key)</td></tr>
<tr class="separator:ga414f75f0d8c025c3e36bd2fa3027db81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021f12a2f5b14413a5e9bc38576e0aad"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename SinglePassRange , typename OutputAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga021f12a2f5b14413a5e9bc38576e0aad"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga021f12a2f5b14413a5e9bc38576e0aad">seek</a> (const SinglePassRange &amp;r, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:ga021f12a2f5b14413a5e9bc38576e0aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1da9024b97456b40a83d48e188903f"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename SinglePassRange , typename KeyRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga9a1da9024b97456b40a83d48e188903f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga9a1da9024b97456b40a83d48e188903f">seek</a> (const SinglePassRange &amp;rng, const KeyRange &amp;key, OutputIterator out)</td></tr>
<tr class="separator:ga9a1da9024b97456b40a83d48e188903f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b253953aed1b9c91f62944b48e22cd5"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename InputIterator , typename KeyIterator , typename CipherAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:ga1b253953aed1b9c91f62944b48e22cd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d1/d74/structnil_1_1crypto3_1_1stream_1_1detail_1_1range__cipher__impl.html">stream::detail::range_cipher_impl</a>&lt; <a class="el" href="../../d2/db5/structnil_1_1crypto3_1_1stream_1_1detail_1_1value__cipher__impl.html">stream::detail::value_cipher_impl</a>&lt; CipherAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#ga1b253953aed1b9c91f62944b48e22cd5">seek</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last)</td></tr>
<tr class="separator:ga1b253953aed1b9c91f62944b48e22cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1deb33d0a1bc13a93f67cc3ac337762"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename InputIterator , typename KeyIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gac1deb33d0a1bc13a93f67cc3ac337762"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#gac1deb33d0a1bc13a93f67cc3ac337762">seek</a> (InputIterator first, InputIterator last, KeyIterator key_first, KeyIterator key_last, OutputIterator out)</td></tr>
<tr class="separator:gac1deb33d0a1bc13a93f67cc3ac337762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc090711f18a27cc16ae2b3f953c0ca"><td class="memTemplParams" colspan="2">template&lt;typename StreamCipher , typename InputIterator , typename OutputAccumulator  = typename stream::stream_accumulator&lt;typename StreamCipher::stream_encrypter_type&gt;&gt; </td></tr>
<tr class="memitem:gabfc090711f18a27cc16ae2b3f953c0ca"><td class="memTemplItemLeft" align="right" valign="top">OutputAccumulator &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d9e/group__stream__algorithms.html#gabfc090711f18a27cc16ae2b3f953c0ca">seek</a> (InputIterator first, InputIterator last, OutputAccumulator &amp;acc)</td></tr>
<tr class="separator:gabfc090711f18a27cc16ae2b3f953c0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2889e7a8d6f9c7e4abe3bb03771d6d51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2889e7a8d6f9c7e4abe3bb03771d6d51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2889e7a8d6f9c7e4abe3bb03771d6d51">set_mem</a> (T *ptr, size_t n, uint8_t val)</td></tr>
<tr class="separator:a2889e7a8d6f9c7e4abe3bb03771d6d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824ff60d3ee31fc1c6a41336ef05733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad824ff60d3ee31fc1c6a41336ef05733">store_be</a> (uint16_t in, uint8_t out[2])</td></tr>
<tr class="separator:ad824ff60d3ee31fc1c6a41336ef05733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72712b818ff84c02bf6b40cf41af67d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a72712b818ff84c02bf6b40cf41af67d4">store_be</a> (uint32_t in, uint8_t out[4])</td></tr>
<tr class="separator:a72712b818ff84c02bf6b40cf41af67d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1df30839fe22078c1c9247901c87abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad1df30839fe22078c1c9247901c87abe">store_be</a> (uint64_t in, uint8_t out[8])</td></tr>
<tr class="separator:ad1df30839fe22078c1c9247901c87abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab97f88ae6618d9ec30d779b3e69275"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ab97f88ae6618d9ec30d779b3e69275"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a3ab97f88ae6618d9ec30d779b3e69275">store_be</a> (uint8_t out[], T x0, T x1)</td></tr>
<tr class="separator:a3ab97f88ae6618d9ec30d779b3e69275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f66f4efc4e1df4b345210f02c2f9e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95f66f4efc4e1df4b345210f02c2f9e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a95f66f4efc4e1df4b345210f02c2f9e3">store_be</a> (uint8_t out[], T x0, T x1, T x2, T x3)</td></tr>
<tr class="separator:a95f66f4efc4e1df4b345210f02c2f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9116e30a49f9ef1f8a6db7cb98a3f83"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9116e30a49f9ef1f8a6db7cb98a3f83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ab9116e30a49f9ef1f8a6db7cb98a3f83">store_be</a> (uint8_t out[], T x0, T x1, T x2, T x3, T x4, T x5, T x6, T x7)</td></tr>
<tr class="separator:ab9116e30a49f9ef1f8a6db7cb98a3f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e8418789516b0df18f07917f24f7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a839e8418789516b0df18f07917f24f7e">store_le</a> (uint16_t in, uint8_t out[2])</td></tr>
<tr class="separator:a839e8418789516b0df18f07917f24f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f617d44280caa177c350ced8e0d0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a85f617d44280caa177c350ced8e0d0fd">store_le</a> (uint32_t in, uint8_t out[4])</td></tr>
<tr class="separator:a85f617d44280caa177c350ced8e0d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35903cf041a451eb29b0afa3e0b2c136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a35903cf041a451eb29b0afa3e0b2c136">store_le</a> (uint64_t in, uint8_t out[8])</td></tr>
<tr class="separator:a35903cf041a451eb29b0afa3e0b2c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adfd70a73131b3f7930cac45660a760"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6adfd70a73131b3f7930cac45660a760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a6adfd70a73131b3f7930cac45660a760">store_le</a> (uint8_t out[], T x0, T x1)</td></tr>
<tr class="separator:a6adfd70a73131b3f7930cac45660a760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d9b8c576778be5e90c3387ac077daa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73d9b8c576778be5e90c3387ac077daa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a73d9b8c576778be5e90c3387ac077daa">store_le</a> (uint8_t out[], T x0, T x1, T x2, T x3)</td></tr>
<tr class="separator:a73d9b8c576778be5e90c3387ac077daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c7520537a5b28c43d10102186495cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70c7520537a5b28c43d10102186495cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a70c7520537a5b28c43d10102186495cb">store_le</a> (uint8_t out[], T x0, T x1, T x2, T x3, T x4, T x5, T x6, T x7)</td></tr>
<tr class="separator:a70c7520537a5b28c43d10102186495cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313b585a5c5b2f58790e557cf9e2700b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a313b585a5c5b2f58790e557cf9e2700b">system_page_size</a> ()</td></tr>
<tr class="separator:a313b585a5c5b2f58790e557cf9e2700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c58e498d17f4ea4552c43fbf1f0298"><td class="memTemplParams" colspan="2">template&lt;unsigned NewBits, unsigned OldBits&gt; </td></tr>
<tr class="memitem:ad4c58e498d17f4ea4552c43fbf1f0298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; NewBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ad4c58e498d17f4ea4552c43fbf1f0298">truncate</a> (const boost::container::small_vector&lt; <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, OldBits/octet_bits &gt; &amp;od)</td></tr>
<tr class="separator:ad4c58e498d17f4ea4552c43fbf1f0298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae98417f42e823ffd20e3d750c4c5dde"><td class="memTemplParams" colspan="2">template&lt;std::size_t NewBits, std::size_t OldBits&gt; </td></tr>
<tr class="memitem:aae98417f42e823ffd20e3d750c4c5dde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; NewBits &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aae98417f42e823ffd20e3d750c4c5dde">truncate</a> (const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; OldBits &gt; &amp;od)</td></tr>
<tr class="separator:aae98417f42e823ffd20e3d750c4c5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5aada4685cbb544f30d1d0a06910f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e5aada4685cbb544f30d1d0a06910f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2e5aada4685cbb544f30d1d0a06910f4">unlock</a> (const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a05a1d69e697fe5dc5f150bcfa0358862">secure_vector</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a2e5aada4685cbb544f30d1d0a06910f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8f718b385f98e883424ee3ec72aa24"><td class="memTemplParams" colspan="2">template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a9f8f718b385f98e883424ee3ec72aa24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a9f8f718b385f98e883424ee3ec72aa24">xor_buf</a> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in, size_t n)</td></tr>
<tr class="separator:a9f8f718b385f98e883424ee3ec72aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18442bee1e5d74738167d781f52695b2"><td class="memTemplParams" colspan="2">template&lt;typename Alloc , typename Alloc2 &gt; </td></tr>
<tr class="memitem:a18442bee1e5d74738167d781f52695b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a18442bee1e5d74738167d781f52695b2">xor_buf</a> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const uint8_t *in, const std::vector&lt; uint8_t, Alloc2 &gt; &amp;in2, size_t n)</td></tr>
<tr class="separator:a18442bee1e5d74738167d781f52695b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605fe19d5b4f21e06a53654702cbf797"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a605fe19d5b4f21e06a53654702cbf797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a605fe19d5b4f21e06a53654702cbf797">xor_buf</a> (std::vector&lt; uint8_t, Alloc &gt; &amp;out, const uint8_t *in, size_t n)</td></tr>
<tr class="separator:a605fe19d5b4f21e06a53654702cbf797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ce80a6ae1c185f235f2d0d82001297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ac0ce80a6ae1c185f235f2d0d82001297">xor_buf</a> (uint8_t out[], const uint8_t in[], const uint8_t in2[], size_t length)</td></tr>
<tr class="separator:ac0ce80a6ae1c185f235f2d0d82001297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2539c81202cb47e2f73547941cc6bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa2539c81202cb47e2f73547941cc6bb9">xor_buf</a> (uint8_t out[], const uint8_t in[], size_t length)</td></tr>
<tr class="separator:aa2539c81202cb47e2f73547941cc6bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3154f3fefcf422617b9d467a8f0abfe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ac3154f3fefcf422617b9d467a8f0abfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#ac3154f3fefcf422617b9d467a8f0abfe">zap</a> (std::vector&lt; T, Alloc &gt; &amp;vec)</td></tr>
<tr class="separator:ac3154f3fefcf422617b9d467a8f0abfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e93933c7b2d98167de107a9278a9fef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:a2e93933c7b2d98167de107a9278a9fef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a2e93933c7b2d98167de107a9278a9fef">zeroise</a> (std::vector&lt; T, Alloc &gt; &amp;vec)</td></tr>
<tr class="separator:a2e93933c7b2d98167de107a9278a9fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa1339a9fee50ef8fd7e95830e49c2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1339a9fee50ef8fd7e95830e49c2d1c">&#9670;&nbsp;</a></span>digest</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DigestBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">nil::crypto3::digest</a> = typedef boost::container::small_vector&lt;<a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, DigestBits / octet_bits&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The digest class template stores a DigestBits-bit message digest as a sequence of 8-bit octets. Octets are stored in the smallest unsigned type able to hold 8 bits, hereinafter referred to as octet_type. DigestBits must be a multiple of 8.</p>
<p>It is independent of any particular algorithm; For example sha2&lt;224&gt; and cubehash&lt;224&gt; both produce a digest&lt;224&gt;. Each algorithm generates its digest such that it will be displayed in the canonical order for that algorithm. The truncate and resize function templates are provided to handle digests with lengths other than you're expecting. For instance, generating name-based UUIDs uses only 128 bits but SHA-1 provides a 160-bit digest, so it would be truncated. (Using truncate instead of resize means that a compilation error will result from trying to use a hash algorithm with too small an output.) On the other hand, for storing as much as possible of the results of various algorithms, resize allows you to pad them out to a large size, such as a digest&lt;512&gt;.</p>
<p>digest&lt;DigestBits&gt; derives publicly from std::array&lt;octet_type, DigestBits/8&gt; and supports all of its operations in order to provide direct access to the contained octets. Note that a digest is not an aggregate; A default-constructed digest has all its contained octets set to zero. The base_array() member function provides a reference to the std::array sub-object.</p>
<p>digests with different numbers of bits may be compared. For the comparison, the smaller is considered as though it were padded with 0s out to the size of the larger. The operator&lt; provides a strict total order. For convenience, equality comparison with narrow c-style strings is also provided.</p>
<p>Always stored internally as a sequence of octets in display order. This allows digests from different algorithms to have the same type, allowing them to be more easily stored and compared.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DigestBits</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0503e99e29f676db5e56ef403ff04d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0503e99e29f676db5e56ef403ff04d17">&#9670;&nbsp;</a></span>octet_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint_t&lt; octet_bits &gt;::least <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">nil::crypto3::octet_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbc9a48566e004d40f7a525952bbb363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc9a48566e004d40f7a525952bbb363">&#9670;&nbsp;</a></span>secure_deque</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#afbc9a48566e004d40f7a525952bbb363">nil::crypto3::secure_deque</a> = typedef std::deque&lt;T, <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05a1d69e697fe5dc5f150bcfa0358862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a1d69e697fe5dc5f150bcfa0358862">&#9670;&nbsp;</a></span>secure_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a05a1d69e697fe5dc5f150bcfa0358862">nil::crypto3::secure_vector</a> = typedef std::vector&lt;T, <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad67ac363b854f5164cdc1ff1ae364bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67ac363b854f5164cdc1ff1ae364bdf">&#9670;&nbsp;</a></span>allocate_locked_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nil::crypto3::allocate_locked_pages </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request so many bytes of page-aligned RAM locked into memory using mlock, VirtualLock, or similar. Returns null on failure. The memory returned is zeroed. Free it with free_locked_pages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>requested allocation in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9ee1d8b012f9a9aee77e495fc507fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ee1d8b012f9a9aee77e495fc507fd8">&#9670;&nbsp;</a></span>allocate_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CRYPTO3_MALLOC_FN void* nil::crypto3::allocate_memory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a memory buffer by some method. This should only be used for primitive types (uint8_t, uint32_t, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td>the number of elements </td></tr>
    <tr><td class="paramname">elem_size</td><td>the size of each element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to allocated and zeroed memory, or throw std::bad_alloc on failure </dd></dl>

</div>
</div>
<a id="aceaba2bf1d1bc97583c0e4b9b584916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaba2bf1d1bc97583c0e4b9b584916e">&#9670;&nbsp;</a></span>bswap_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::bswap_4 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap 4 Ts in an array </p>

</div>
</div>
<a id="a8350641ae0dac5d8006cc79082f7d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8350641ae0dac5d8006cc79082f7d446">&#9670;&nbsp;</a></span>buffer_insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t nil::crypto3::buffer_insert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3963efe053611f9acc1c08c5081429b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3963efe053611f9acc1c08c5081429b4">&#9670;&nbsp;</a></span>buffer_insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t nil::crypto3::buffer_insert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buf_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>input_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5a5fd7ee0ee51b570b16d0901f30947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a5fd7ee0ee51b570b16d0901f30947">&#9670;&nbsp;</a></span>cast_char_ptr_to_uint8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* nil::crypto3::cast_char_ptr_to_uint8 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a105237964a746086e39a6d57c3b30fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105237964a746086e39a6d57c3b30fba">&#9670;&nbsp;</a></span>cast_char_ptr_to_uint8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* nil::crypto3::cast_char_ptr_to_uint8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae888a507bc7a9409eff9ab6a7323162a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae888a507bc7a9409eff9ab6a7323162a">&#9670;&nbsp;</a></span>cast_uint8_ptr_to_char() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* nil::crypto3::cast_uint8_ptr_to_char </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06383f87da474f094510c35f5c28eaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06383f87da474f094510c35f5c28eaa1">&#9670;&nbsp;</a></span>cast_uint8_ptr_to_char() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* nil::crypto3::cast_uint8_ptr_to_char </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a937392c8a0bcc966ede0e8e88d54e0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937392c8a0bcc966ede0e8e88d54e0df">&#9670;&nbsp;</a></span>clear_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::clear_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zero out some bytes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to memory to zero </td></tr>
    <tr><td class="paramname">bytes</td><td>the number of bytes to zero in ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc9ecd704d764c05e25c8d3f5219536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc9ecd704d764c05e25c8d3f5219536">&#9670;&nbsp;</a></span>clear_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::clear_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Zero memory before use. This simply calls memset and should not be used in cases where the compiler cannot see the call as a side-effecting operation (for example, if calling clear_mem before deallocating memory, the compiler would be allowed to omit the call to memset entirely under the as-if rule.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array of Ts to zero </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts pointed to by ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbdebb8ac8de97d40e3a8fa42cd0844a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdebb8ac8de97d40e3a8fa42cd0844a">&#9670;&nbsp;</a></span>constant_time_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::constant_time_compare </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory comparison, input insensitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">y</td><td>a pointer to another array </td></tr>
    <tr><td class="paramname">len</td><td>the number of Ts in x and y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff x[i] == y[i] forall i in [0...n) </dd></dl>

</div>
</div>
<a id="ad70ff4d0dfd1067496b47450d80e6ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70ff4d0dfd1067496b47450d80e6ae3">&#9670;&nbsp;</a></span>copy_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::copy_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the destination array </td></tr>
    <tr><td class="paramname">in</td><td>the source array </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements of in/out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7412e5a3015574031af2fd1cb98f2027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7412e5a3015574031af2fd1cb98f2027">&#9670;&nbsp;</a></span>deallocate_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::deallocate_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a pointer returned by allocate_memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pointer returned by allocate_memory </td></tr>
    <tr><td class="paramname">elems</td><td>the number of elements, as passed to allocate_memory </td></tr>
    <tr><td class="paramname">elem_size</td><td>the size of each element, as passed to allocate_memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d74ab736058fa28aff4b9b2b283ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d74ab736058fa28aff4b9b2b283ff5">&#9670;&nbsp;</a></span>free_locked_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::free_locked_pages </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free memory allocated by allocate_locked_pages </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer returned by allocate_locked_pages </td></tr>
    <tr><td class="paramname">length</td><td>length passed to allocate_locked_pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8f97dbe038592a7326a8ae794943d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8f97dbe038592a7326a8ae794943d8">&#9670;&nbsp;</a></span>gcm_multiply_ssse3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::gcm_multiply_ssse3 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>x</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>HM</em>[256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21742d87e3298ca4c04746bb8efff57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21742d87e3298ca4c04746bb8efff57d">&#9670;&nbsp;</a></span>get_high_resolution_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CRYPTO3_TEST_API nil::crypto3::get_high_resolution_clock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>best resolution timestamp available</dd></dl>
<p>The epoch and update rate of this clock is arbitrary and depending on the hardware it may not tick at a constant rate.</p>
<p>Uses hardware cycle counter, if available. On POSIX platforms clock_gettime is used with a monotonic timer As a final fallback std::chrono::high_resolution_clock is used. </p>

</div>
</div>
<a id="aace19955c4ae91c8be89c1c57116853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace19955c4ae91c8be89c1c57116853d">&#9670;&nbsp;</a></span>get_memory_locking_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nil::crypto3::get_memory_locking_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum amount of memory (in bytes) could/should be hyptothetically allocated for the memory pool. Reads environment variable "CRYPTO3_MLOCK_POOL_SIZE", set to "0" to disable pool. </dd></dl>

</div>
</div>
<a id="a8b5b2a5393e6c9f3fa2c7a66a464c496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5b2a5393e6c9f3fa2c7a66a464c496">&#9670;&nbsp;</a></span>get_process_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CRYPTO3_TEST_API nil::crypto3::get_process_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>process ID assigned by the operating system. On Unix and Windows systems, this always returns a result On IncludeOS it returns 0 since there is no process ID to speak of in a unikernel. </dd></dl>

</div>
</div>
<a id="a2ebb68a60534ac9243af868678b2fab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebb68a60534ac9243af868678b2fab1">&#9670;&nbsp;</a></span>get_processor_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CRYPTO3_TEST_API nil::crypto3::get_processor_timestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>CPU processor clock, if available</dd></dl>
<p>On Windows, calls QueryPerformanceCounter.</p>
<p>Under GCC or Clang on supported platforms the hardware cycle counter is queried. Currently supported processors are x86, PPC, Alpha, SPARC, IA-64, S/390x, and HP-PA. If no CPU cycle counter is available on this system, returns zero. </p>

</div>
</div>
<a id="a8eb1ded8fdf6173ce53a51f90d00ddd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb1ded8fdf6173ce53a51f90d00ddd6">&#9670;&nbsp;</a></span>get_system_timestamp_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nil::crypto3::get_system_timestamp_ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>system clock (reflecting wall clock) with best resolution available, normalized to nanoseconds resolution. </dd></dl>

</div>
</div>
<a id="a845e6cc9dfa5727d5a7ae03c18268587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845e6cc9dfa5727d5a7ae03c18268587">&#9670;&nbsp;</a></span>initialize_allocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::initialize_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure the allocator is initialized </p>

</div>
</div>
<a id="a38be7a1b17ec76efbe55194857dfb173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38be7a1b17ec76efbe55194857dfb173">&#9670;&nbsp;</a></span>load_be() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian word </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th T of in, as a big-endian value </dd></dl>

</div>
</div>
<a id="a525fb18e9ffe2b22b263778fad0ea026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525fb18e9ffe2b22b263778fad0ea026">&#9670;&nbsp;</a></span>load_be() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load two big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6616c4d96004335321c9df387edad23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6616c4d96004335321c9df387edad23">&#9670;&nbsp;</a></span>load_be() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load four big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a511bb2256a079d512ef170882f6e6997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511bb2256a079d512ef170882f6e6997">&#9670;&nbsp;</a></span>load_be() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_be </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load eight big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
    <tr><td class="paramname">x4</td><td>where the fifth word will be written </td></tr>
    <tr><td class="paramname">x5</td><td>where the sixth word will be written </td></tr>
    <tr><td class="paramname">x6</td><td>where the seventh word will be written </td></tr>
    <tr><td class="paramname">x7</td><td>where the eighth word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b8852c501b4993c81a7c3bcc8456a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8852c501b4993c81a7c3bcc8456a46">&#9670;&nbsp;</a></span>load_be() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_be </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a variable number of big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of words </td></tr>
    <tr><td class="paramname">in</td><td>the input array of bytes </td></tr>
    <tr><td class="paramname">count</td><td>how many words are in in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa849feff6fc18f946268b5fa03239e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa849feff6fc18f946268b5fa03239e4">&#9670;&nbsp;</a></span>load_be&lt; uint16_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a38be7a1b17ec76efbe55194857dfb173">nil::crypto3::load_be</a>&lt; uint16_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint16_t of in, as a big-endian value </dd></dl>

</div>
</div>
<a id="afae26a36e78ba432dc653e728b16772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae26a36e78ba432dc653e728b16772d">&#9670;&nbsp;</a></span>load_be&lt; uint32_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a38be7a1b17ec76efbe55194857dfb173">nil::crypto3::load_be</a>&lt; uint32_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint32_t of in, as a big-endian value </dd></dl>

</div>
</div>
<a id="afbf744ffa3246c8511fc423b4753e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf744ffa3246c8511fc423b4753e597">&#9670;&nbsp;</a></span>load_be&lt; uint64_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a38be7a1b17ec76efbe55194857dfb173">nil::crypto3::load_be</a>&lt; uint64_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a big-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint64_t of in, as a big-endian value </dd></dl>

</div>
</div>
<a id="a492c34cc071c3bdc388dfd2b16f20f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492c34cc071c3bdc388dfd2b16f20f9d">&#9670;&nbsp;</a></span>load_le() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian word </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th T of in, as a litte-endian value </dd></dl>

</div>
</div>
<a id="a2ac4acdd73a613030cc33078e14788c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac4acdd73a613030cc33078e14788c1">&#9670;&nbsp;</a></span>load_le() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load two little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aee66028e24ca6e3f8bc310ced3061e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee66028e24ca6e3f8bc310ced3061e">&#9670;&nbsp;</a></span>load_le() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load four little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30c7a14cf694d7fbe480370b4290302f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c7a14cf694d7fbe480370b4290302f">&#9670;&nbsp;</a></span>load_le() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_le </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load eight little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">x0</td><td>where the first word will be written </td></tr>
    <tr><td class="paramname">x1</td><td>where the second word will be written </td></tr>
    <tr><td class="paramname">x2</td><td>where the third word will be written </td></tr>
    <tr><td class="paramname">x3</td><td>where the fourth word will be written </td></tr>
    <tr><td class="paramname">x4</td><td>where the fifth word will be written </td></tr>
    <tr><td class="paramname">x5</td><td>where the sixth word will be written </td></tr>
    <tr><td class="paramname">x6</td><td>where the seventh word will be written </td></tr>
    <tr><td class="paramname">x7</td><td>where the eighth word will be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa59c79c30e35917703ec8cd1f61aedb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59c79c30e35917703ec8cd1f61aedb1">&#9670;&nbsp;</a></span>load_le() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::load_le </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a variable number of little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output array of words </td></tr>
    <tr><td class="paramname">in</td><td>the input array of bytes </td></tr>
    <tr><td class="paramname">count</td><td>how many words are in in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b794fd5fcfc548c2a6f85233784c498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b794fd5fcfc548c2a6f85233784c498">&#9670;&nbsp;</a></span>load_le&lt; uint16_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a492c34cc071c3bdc388dfd2b16f20f9d">nil::crypto3::load_le</a>&lt; uint16_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint16_t of in, as a little-endian value </dd></dl>

</div>
</div>
<a id="a3d51b42fa4c991fdc659d656f4883884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d51b42fa4c991fdc659d656f4883884">&#9670;&nbsp;</a></span>load_le&lt; uint32_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a492c34cc071c3bdc388dfd2b16f20f9d">nil::crypto3::load_le</a>&lt; uint32_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint32_t of in, as a little-endian value </dd></dl>

</div>
</div>
<a id="ac5d6109b3527bb9c10f023d9cd9881ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d6109b3527bb9c10f023d9cd9881ef">&#9670;&nbsp;</a></span>load_le&lt; uint64_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a492c34cc071c3bdc388dfd2b16f20f9d">nil::crypto3::load_le</a>&lt; uint64_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load a little-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>a pointer to some bytes </td></tr>
    <tr><td class="paramname">off</td><td>an offset into the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>off'th uint64_t of in, as a little-endian value </dd></dl>

</div>
</div>
<a id="a5b080e10b40cc35de320d9366ea96290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b080e10b40cc35de320d9366ea96290">&#9670;&nbsp;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="../../de/df4/namespacenil_1_1crypto3_1_1detail.html#ad5131c13a1c31af003ac83bf1bea63f2">detail::ValueType</a>&lt; RandomAccessIterator &gt;, N &gt; nil::crypto3::make_array </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec50e505271d8d408ec05764b291380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec50e505271d8d408ec05764b291380c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a856408b83a196cc2ba71100584c0fadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856408b83a196cc2ba71100584c0fadc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19602fe221bd2fce600a97aeca7bfd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19602fe221bd2fce600a97aeca7bfd0e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a453a3243a8cbca962d31dbb31e4daee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453a3243a8cbca962d31dbb31e4daee3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0e8f627f2a864c3ddbae288b76fee2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e8f627f2a864c3ddbae288b76fee2f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afeffedd8ec03595f789e9ce271902936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeffedd8ec03595f789e9ce271902936">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac802c5106106e6f5544222773aa79540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac802c5106106e6f5544222773aa79540">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65ee6f5e44fd9558243adf14913704cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ee6f5e44fd9558243adf14913704cf">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T, Alloc&gt;&amp; nil::crypto3::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; const T *, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad67c1311e009eaacf2751db1cef06f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67c1311e009eaacf2751db1cef06f99">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T, Alloc&gt;&amp; nil::crypto3::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T *, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab298426e1918d6dda83e039062839465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab298426e1918d6dda83e039062839465">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T, Alloc&gt;&amp; nil::crypto3::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eab9ab9c6cd50d8dc9a1162cddf26f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eab9ab9c6cd50d8dc9a1162cddf26f2">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T, Alloc&gt;&amp; nil::crypto3::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34195078240699cb0147892005ffba5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34195078240699cb0147892005ffba5a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d39b53ac186c14b014eddb95174bca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d39b53ac186c14b014eddb95174bca5">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d3b571726da4a4b6511fda0aad6a0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3b571726da4a4b6511fda0aad6a0cf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DigestBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nil::crypto3::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DigestBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a488334bf4dce5e610badea2bd664cf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488334bf4dce5e610badea2bd664cf33">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; nil::crypto3::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9658785b70dd12cfbfc6c66717d2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9658785b70dd12cfbfc6c66717d2d1c">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac743d422b8b359d34a0e3cadbd5278c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac743d422b8b359d34a0e3cadbd5278c2">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af02b241c1f81baf6414599e4f4d500d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02b241c1f81baf6414599e4f4d500d1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af54963797f7768b0865b398e0c981155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54963797f7768b0865b398e0c981155">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf672ac7a3ef7de2e4dda1051c424593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf672ac7a3ef7de2e4dda1051c424593">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b64ed782f62d20cec19b14d7f8bf803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b64ed782f62d20cec19b14d7f8bf803">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/d8e/classnil_1_1crypto3_1_1secure__allocator.html">secure_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa82f3edb1640350c8498a62efe5532df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82f3edb1640350c8498a62efe5532df">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0ae0c492a3615b931c63f0917f364a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae0c492a3615b931c63f0917f364a8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acba4fe0782ab5783b85650ec764511d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba4fe0782ab5783b85650ec764511d0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c23d68dc09b513f802739dc55065a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c23d68dc09b513f802739dc55065a6">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf2892e849ab867d1b9c0516ce9c7227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2892e849ab867d1b9c0516ce9c7227">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6d0a9c0c0ab105d354d8a2a076e7d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d0a9c0c0ab105d354d8a2a076e7d0c">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB1, unsigned DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af84c1dd77b136672ca8a1675c10f1156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84c1dd77b136672ca8a1675c10f1156">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DB1, std::size_t DB2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DB2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c662fab3d36e755d5736b3147dd7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c662fab3d36e755d5736b3147dd7a0">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned DB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; nil::crypto3::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; DB &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68ed5adb0e11e42db7b611572c3eca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ed5adb0e11e42db7b611572c3eca59">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DigestBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; nil::crypto3::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; DigestBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2bd2b64f053986f8a03e87c58b6dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2bd2b64f053986f8a03e87c58b6dc64">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc , typename Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t, Alloc&gt;&amp; nil::crypto3::operator^= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae11f921a5a437e5587540cec2e19f317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11f921a5a437e5587540cec2e19f317">&#9670;&nbsp;</a></span>poly_double_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::poly_double_n </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c379ab3e28936f5cf8e818814f0c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c379ab3e28936f5cf8e818814f0c66">&#9670;&nbsp;</a></span>poly_double_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::poly_double_n </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Polynomial doubling in GF(2^n) </p>

</div>
</div>
<a id="a23303c0d13da227018c7dbb51eeddb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23303c0d13da227018c7dbb51eeddb61">&#9670;&nbsp;</a></span>poly_double_n_le()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::poly_double_n_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a5ea0fac2e190691e9899e8be0e48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a5ea0fac2e190691e9899e8be0e48c">&#9670;&nbsp;</a></span>poly_double_supported_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool nil::crypto3::poly_double_supported_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff poly_double_n is implemented for this size. </p>

</div>
</div>
<a id="a26fd11fb22126f4c52151714e7595cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fd11fb22126f4c52151714e7595cfc">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned NewBits, unsigned OldBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; NewBits &gt; nil::crypto3::resize </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, OldBits/octet_bits &gt; &amp;&#160;</td>
          <td class="paramname"><em>od</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewBits</td><td></td></tr>
    <tr><td class="paramname">OldBits</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">od</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Digest containing the first min(NewBits, OldBits) bits of the argument digest followed by max (0, NewBits - OldBits) bits. </dd></dl>

</div>
</div>
<a id="a01b208eaeff49aa255733e8efdc2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b208eaeff49aa255733e8efdc2b682">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NewBits, std::size_t OldBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; NewBits &gt; nil::crypto3::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; OldBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>od</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewBits</td><td></td></tr>
    <tr><td class="paramname">OldBits</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">od</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Digest containing the first min(NewBits, OldBits) bits of the argument digest followed by max (0, NewBits - OldBits) bits. </dd></dl>

</div>
</div>
<a id="a97c9b88625038d29bb51ccc7af239aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c9b88625038d29bb51ccc7af239aa4">&#9670;&nbsp;</a></span>rotl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ROT, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::rotl </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation left by a compile-time constant amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated left by ROT bits </dd></dl>

</div>
</div>
<a id="aeff3f74d5539611e2fa13406db81f54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff3f74d5539611e2fa13406db81f54d">&#9670;&nbsp;</a></span>rotl_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::rotl_var </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation left, variable rotation amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
    <tr><td class="paramname">rot</td><td>the number of bits to rotate, must be between 0 and sizeof(T)*8-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated left by rot bits </dd></dl>

</div>
</div>
<a id="aefed267f1bf68268bf576a862c1ca2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefed267f1bf68268bf576a862c1ca2e6">&#9670;&nbsp;</a></span>rotr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t ROT, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::rotr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation right by a compile-time constant amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated right by ROT bits </dd></dl>

</div>
</div>
<a id="ab1d04ec1b177afa6d32e7d064ac7f026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d04ec1b177afa6d32e7d064ac7f026">&#9670;&nbsp;</a></span>rotr_var()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T nil::crypto3::rotr_var </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bit rotation right, variable rotation amount </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input word </td></tr>
    <tr><td class="paramname">rot</td><td>the number of bits to rotate, must be between 0 and sizeof(T)*8-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input rotated right by rot bits </dd></dl>

</div>
</div>
<a id="a311f90015437d1bd9ed31ff946e2a780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311f90015437d1bd9ed31ff946e2a780">&#9670;&nbsp;</a></span>run_cpu_instruction_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CRYPTO3_TEST_API nil::crypto3::run_cpu_instruction_probe </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; int()&gt;&#160;</td>
          <td class="paramname"><em>probe_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a probe instruction to test for support for a CPU instruction. Runs in system-specific env that catches illegal instructions; this function always fails if the OS doesn't provide this. Returns value of probe_fn, if it could run. If error occurs, returns negative number. This allows probe_fn to indicate errors of its own, if it wants. For example the instruction might not only be only available on some CPUs, but also buggy on some subset of these - the probe function can test to make sure the instruction works properly before indicating that the instruction is available.</p>
<dl class="section warning"><dt>Warning</dt><dd>on Unix systems uses signal handling in a way that is not thread safe. It should only be called in a single-threaded context (ie, at static init time).</dd></dl>
<p>If probe_fn throws an exception the result is undefined.</p>
<p>Return codes: -1 illegal instruction detected </p>

</div>
</div>
<a id="a54d4828af376c542be8d410e932859d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d4828af376c542be8d410e932859d7">&#9670;&nbsp;</a></span>same_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool nil::crypto3::same_mem </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory comparison, input insensitive </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">p2</td><td>a pointer to another array </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts in p1 and p2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff p1[i] == p2[i] forall i in [0...n) </dd></dl>

</div>
</div>
<a id="a34c33a4538a65259747fa955c3df71b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c33a4538a65259747fa955c3df71b4">&#9670;&nbsp;</a></span>secure_scrub_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::secure_scrub_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scrub memory contents in a way that a compiler should not elide, using some system specific technique. Note that this function might not zero the memory (for example, in some hypothetical implementation it might combine the memory contents with the output of a system PRNG), but if you can detect any difference in behavior at runtime then the clearing is side-effecting and you can just use <code>clear_mem</code>.</p>
<p>Use this function to scrub memory just before deallocating it, or on a stack buffer before returning from the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to memory to scrub </td></tr>
    <tr><td class="paramname">n</td><td>the number of bytes pointed to by ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2889e7a8d6f9c7e4abe3bb03771d6d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2889e7a8d6f9c7e4abe3bb03771d6d51">&#9670;&nbsp;</a></span>set_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::set_mem </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set memory to a fixed value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>a pointer to an array </td></tr>
    <tr><td class="paramname">n</td><td>the number of Ts pointed to by ptr </td></tr>
    <tr><td class="paramname">val</td><td>the value to set each byte to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad824ff60d3ee31fc1c6a41336ef05733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad824ff60d3ee31fc1c6a41336ef05733">&#9670;&nbsp;</a></span>store_be() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint16_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72712b818ff84c02bf6b40cf41af67d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72712b818ff84c02bf6b40cf41af67d4">&#9670;&nbsp;</a></span>store_be() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint32_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1df30839fe22078c1c9247901c87abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1df30839fe22078c1c9247901c87abe">&#9670;&nbsp;</a></span>store_be() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a big-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint64_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ab97f88ae6618d9ec30d779b3e69275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab97f88ae6618d9ec30d779b3e69275">&#9670;&nbsp;</a></span>store_be() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store two big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f66f4efc4e1df4b345210f02c2f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f66f4efc4e1df4b345210f02c2f9e3">&#9670;&nbsp;</a></span>store_be() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store four big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9116e30a49f9ef1f8a6db7cb98a3f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9116e30a49f9ef1f8a6db7cb98a3f83">&#9670;&nbsp;</a></span>store_be() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_be </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store eight big-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
    <tr><td class="paramname">x4</td><td>the fifth word </td></tr>
    <tr><td class="paramname">x5</td><td>the sixth word </td></tr>
    <tr><td class="paramname">x6</td><td>the seventh word </td></tr>
    <tr><td class="paramname">x7</td><td>the eighth word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839e8418789516b0df18f07917f24f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e8418789516b0df18f07917f24f7e">&#9670;&nbsp;</a></span>store_le() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint16_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint16_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85f617d44280caa177c350ced8e0d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f617d44280caa177c350ced8e0d0fd">&#9670;&nbsp;</a></span>store_le() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint32_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35903cf041a451eb29b0afa3e0b2c136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35903cf041a451eb29b0afa3e0b2c136">&#9670;&nbsp;</a></span>store_le() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a little-endian uint64_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input uint64_t </td></tr>
    <tr><td class="paramname">out</td><td>the byte array to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6adfd70a73131b3f7930cac45660a760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adfd70a73131b3f7930cac45660a760">&#9670;&nbsp;</a></span>store_le() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store two little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d9b8c576778be5e90c3387ac077daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d9b8c576778be5e90c3387ac077daa">&#9670;&nbsp;</a></span>store_le() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store four little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70c7520537a5b28c43d10102186495cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c7520537a5b28c43d10102186495cb">&#9670;&nbsp;</a></span>store_le() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::store_le </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store eight little-endian words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output byte array </td></tr>
    <tr><td class="paramname">x0</td><td>the first word </td></tr>
    <tr><td class="paramname">x1</td><td>the second word </td></tr>
    <tr><td class="paramname">x2</td><td>the third word </td></tr>
    <tr><td class="paramname">x3</td><td>the fourth word </td></tr>
    <tr><td class="paramname">x4</td><td>the fifth word </td></tr>
    <tr><td class="paramname">x5</td><td>the sixth word </td></tr>
    <tr><td class="paramname">x6</td><td>the seventh word </td></tr>
    <tr><td class="paramname">x7</td><td>the eighth word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a313b585a5c5b2f58790e557cf9e2700b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313b585a5c5b2f58790e557cf9e2700b">&#9670;&nbsp;</a></span>system_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nil::crypto3::system_page_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of a memory page, if that can be derived on the current system. Otherwise returns some default value (eg 4096) </p>

</div>
</div>
<a id="ad4c58e498d17f4ea4552c43fbf1f0298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c58e498d17f4ea4552c43fbf1f0298">&#9670;&nbsp;</a></span>truncate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned NewBits, unsigned OldBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#aa1339a9fee50ef8fd7e95830e49c2d1c">digest</a>&lt; NewBits &gt; nil::crypto3::truncate </td>
          <td>(</td>
          <td class="paramtype">const boost::container::small_vector&lt; <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a0503e99e29f676db5e56ef403ff04d17">octet_type</a>, OldBits/octet_bits &gt; &amp;&#160;</td>
          <td class="paramname"><em>od</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewBits</td><td></td></tr>
    <tr><td class="paramname">OldBits</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Digest containing only the first NewBits bits of the argument digest.</dd></dl>
<p>Requires that NewBits &lt;= OldBits.</p>
<p>Truncating a message digest generally does not weaken the hash algorithm beyond the amount necessitated by the shorted output size. </p>

</div>
</div>
<a id="aae98417f42e823ffd20e3d750c4c5dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae98417f42e823ffd20e3d750c4c5dde">&#9670;&nbsp;</a></span>truncate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NewBits, std::size_t OldBits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; NewBits &gt; nil::crypto3::truncate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d5e/classnil_1_1crypto3_1_1static__digest.html">static_digest</a>&lt; OldBits &gt; &amp;&#160;</td>
          <td class="paramname"><em>od</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewBits</td><td></td></tr>
    <tr><td class="paramname">OldBits</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Digest containing only the first NewBits bits of the argument digest.</dd></dl>
<p>Requires that NewBits &lt;= OldBits.</p>
<p>Truncating a message digest generally does not weaken the hash algorithm beyond the amount necessitated by the shorted output size. </p>

</div>
</div>
<a id="a2e5aada4685cbb544f30d1d0a06910f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5aada4685cbb544f30d1d0a06910f4">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; nil::crypto3::unlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d6c/namespacenil_1_1crypto3.html#a05a1d69e697fe5dc5f150bcfa0358862">secure_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f8f718b385f98e883424ee3ec72aa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8f718b385f98e883424ee3ec72aa24">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc , typename Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::xor_buf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18442bee1e5d74738167d781f52695b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18442bee1e5d74738167d781f52695b2">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc , typename Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::xor_buf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint8_t, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a605fe19d5b4f21e06a53654702cbf797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605fe19d5b4f21e06a53654702cbf797">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::xor_buf </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0ce80a6ae1c185f235f2d0d82001297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ce80a6ae1c185f235f2d0d82001297">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::xor_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>XOR arrays. Postcondition out[i] = in[i] ^ in2[i] forall i = 0...length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">in</td><td>the first input buffer </td></tr>
    <tr><td class="paramname">in2</td><td>the second output buffer </td></tr>
    <tr><td class="paramname">length</td><td>the length of the three buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2539c81202cb47e2f73547941cc6bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2539c81202cb47e2f73547941cc6bb9">&#9670;&nbsp;</a></span>xor_buf() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::xor_buf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>XOR arrays. Postcondition out[i] = in[i] ^ out[i] forall i = 0...length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the input/output buffer </td></tr>
    <tr><td class="paramname">in</td><td>the read-only input buffer </td></tr>
    <tr><td class="paramname">length</td><td>the length of the buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3154f3fefcf422617b9d467a8f0abfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3154f3fefcf422617b9d467a8f0abfe">&#9670;&nbsp;</a></span>zap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::zap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroise the values then free the memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector to zeroise and free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e93933c7b2d98167de107a9278a9fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e93933c7b2d98167de107a9278a9fef">&#9670;&nbsp;</a></span>zeroise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void nil::crypto3::zeroise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroise the values; length remains unchanged </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the vector to zeroise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<address class="footer"><!--<small>
Generated on Tue Feb 11 2020 13:11:45 for =nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small>--></address>
</body>
<script type="text/javascript" src="../../doxy_boot.js"></script>
</html>
