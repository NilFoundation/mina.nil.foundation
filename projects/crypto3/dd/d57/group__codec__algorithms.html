<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.17"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <title>=nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library: Algorithms</title>
    <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="../../dynsections.js"></script>
    <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
    <link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../../bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <!-- SmartMenus jQuery Plugin -->
    <script type="text/javascript" src="../../jquery.smartmenus.js"></script>
    <!-- SmartMenus jQuery Bootstrap Addon -->
    <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.js"></script>
    <!-- highlight.js Syntax Highlighter -->
    <link rel="stylesheet" href="../../darkula.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.16.2/build/highlight.min.js"></script>
    <!--    <script>-->
    <!--        $(function () {-->
    <!--            $(".fragment").each(function (i, node) {-->
    <!--                var $node = $(node);-->
    <!--                $node.html("<pre><code class='" +-->
    <!--                    $node.attr("class") + "'>" +-->
    <!--                    $node.text() + "</code></pre>");-->
    <!--                hljs.highlightBlock(node);-->
    <!--            });-->
    <!--        });-->
    <!--    </script>-->
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand">=nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library 0.3.0</a>
        </div>
    </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div class="content" id="content">
        <div class="container">
            <div class="row">
                <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                    <div style="margin-bottom: 15px;">
                        <!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms<div class="ingroups"><a class="el" href="../../db/d97/group__codec.html">Encoding &amp; Decoding</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Algorithms are meant to provide decoding interface similar to STL algorithms' one.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Algorithms:</div>
<div class="dyncontent">
<div class="center"><img src="../../dd/d57/group__codec__algorithms.png" border="0" usemap="#dd_2d57_2group____codec____algorithms" alt=""/></div>
<map name="dd_2d57_2group____codec____algorithms" id="dd_2d57_2group____codec____algorithms">
<area shape="rect" title="Algorithms are meant to provide decoding interface similar to STL algorithms&#39; one." alt="" coords="204,5,289,31"/>
<area shape="rect" href="../../db/d97/group__codec.html" title=" " alt="" coords="5,5,156,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaddd92f786fc08579a54dc35dd53473f8"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaddd92f786fc08579a54dc35dd53473f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaddd92f786fc08579a54dc35dd53473f8">nil::crypto3::decode</a> (const SinglePassRange &amp;r)</td></tr>
<tr class="memdesc:gaddd92f786fc08579a54dc35dd53473f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaddd92f786fc08579a54dc35dd53473f8">More...</a><br /></td></tr>
<tr class="separator:gaddd92f786fc08579a54dc35dd53473f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga3bfad0676c2297534c4b6a2fc81b14f7">nil::crypto3::decode</a> (const SinglePassRange &amp;rng, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga3bfad0676c2297534c4b6a2fc81b14f7">More...</a><br /></td></tr>
<tr class="separator:ga3bfad0676c2297534c4b6a2fc81b14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029ac12764148d33976f1f5633ba3e4e"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename SinglePassRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga029ac12764148d33976f1f5633ba3e4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga029ac12764148d33976f1f5633ba3e4e">nil::crypto3::decode</a> (const SinglePassRange &amp;rng, OutputIterator out)</td></tr>
<tr class="memdesc:ga029ac12764148d33976f1f5633ba3e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga029ac12764148d33976f1f5633ba3e4e">More...</a><br /></td></tr>
<tr class="separator:ga029ac12764148d33976f1f5633ba3e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga9b380b63793f8b569d9b993763ddfe2a">nil::crypto3::decode</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ga9b380b63793f8b569d9b993763ddfe2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#ga9b380b63793f8b569d9b993763ddfe2a">More...</a><br /></td></tr>
<tr class="separator:ga9b380b63793f8b569d9b993763ddfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga10ff91e4a363478d87dc7744dc1f3756">nil::crypto3::decode</a> (InputIterator first, InputIterator last, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga10ff91e4a363478d87dc7744dc1f3756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga10ff91e4a363478d87dc7744dc1f3756">More...</a><br /></td></tr>
<tr class="separator:ga10ff91e4a363478d87dc7744dc1f3756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05c728507aab1602959b4975b09764"><td class="memTemplParams" colspan="2">template&lt;typename Decoder , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gafd05c728507aab1602959b4975b09764"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gafd05c728507aab1602959b4975b09764">nil::crypto3::decode</a> (InputIterator first, InputIterator last, OutputIterator out)</td></tr>
<tr class="memdesc:gafd05c728507aab1602959b4975b09764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last), and inserts the result to another range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gafd05c728507aab1602959b4975b09764">More...</a><br /></td></tr>
<tr class="separator:gafd05c728507aab1602959b4975b09764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaa731755d2bec7fd2dc9c33f5648b8a5c">nil::crypto3::encode</a> (const SinglePassRange &amp;r)</td></tr>
<tr class="memdesc:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaa731755d2bec7fd2dc9c33f5648b8a5c">More...</a><br /></td></tr>
<tr class="separator:gaa731755d2bec7fd2dc9c33f5648b8a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753e9fac08375391143e153b68cc86cd"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:ga753e9fac08375391143e153b68cc86cd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#ga753e9fac08375391143e153b68cc86cd">nil::crypto3::encode</a> (const SinglePassRange &amp;rng, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:ga753e9fac08375391143e153b68cc86cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#ga753e9fac08375391143e153b68cc86cd">More...</a><br /></td></tr>
<tr class="separator:ga753e9fac08375391143e153b68cc86cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename SinglePassRange , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gadc52aa495b9ffc48fa969d4059eb2229">nil::crypto3::encode</a> (const SinglePassRange &amp;rng, OutputIterator out)</td></tr>
<tr class="memdesc:gadc52aa495b9ffc48fa969d4059eb2229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gadc52aa495b9ffc48fa969d4059eb2229">More...</a><br /></td></tr>
<tr class="separator:gadc52aa495b9ffc48fa969d4059eb2229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt; <a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt; CodecAccumulator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaca6eac88a0bbb2b6965918a491540eb4">nil::crypto3::encode</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:gaca6eac88a0bbb2b6965918a491540eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaca6eac88a0bbb2b6965918a491540eb4">More...</a><br /></td></tr>
<tr class="separator:gaca6eac88a0bbb2b6965918a491540eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e74d24b6641215095b9c8409c99361"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </td></tr>
<tr class="memitem:gaa4e74d24b6641215095b9c8409c99361"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; boost::accumulators::detail::is_accumulator_set&lt; CodecAccumulator &gt;::value, CodecAccumulator &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gaa4e74d24b6641215095b9c8409c99361">nil::crypto3::encode</a> (InputIterator first, InputIterator last, CodecAccumulator &amp;acc)</td></tr>
<tr class="memdesc:gaa4e74d24b6641215095b9c8409c99361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with type satisfying AccumulatorSet requirements.  <a href="../../dd/d57/group__codec__algorithms.html#gaa4e74d24b6641215095b9c8409c99361">More...</a><br /></td></tr>
<tr class="separator:gaa4e74d24b6641215095b9c8409c99361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memTemplParams" colspan="2">template&lt;typename Encoder , typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt; OutputIterator &gt;::value, OutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dd/d57/group__codec__algorithms.html#gad8327c5f73064ccefe2f1bbc7abe5e9e">nil::crypto3::encode</a> (InputIterator first, InputIterator last, OutputIterator out)</td></tr>
<tr class="memdesc:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last), and inserts the result to another range beginning at out.  <a href="../../dd/d57/group__codec__algorithms.html#gad8327c5f73064ccefe2f1bbc7abe5e9e">More...</a><br /></td></tr>
<tr class="separator:gad8327c5f73064ccefe2f1bbc7abe5e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms are meant to provide decoding interface similar to STL algorithms' one. </p>
<p>Encoding algorithms are meant to provide encoding interface similar to STL algorithms' one.</p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaddd92f786fc08579a54dc35dd53473f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddd92f786fc08579a54dc35dd53473f8">&#9670;&nbsp;</a></span>decode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt;<a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt;CodecAccumulator&gt; &gt; nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Defines the range to be processed by decoder.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decoded data emplaced in any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </dd></dl>

</div>
</div>
<a id="ga3bfad0676c2297534c4b6a2fc81b14f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bfad0676c2297534c4b6a2fc81b14f7">&#9670;&nbsp;</a></span>decode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;boost::accumulators::detail::is_accumulator_set&lt;CodecAccumulator&gt;::value, CodecAccumulator&gt;::type&amp; nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CodecAccumulator &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Defines the range to be processed by decoder. </td></tr>
    <tr><td class="paramname">acc</td><td>AccumulatorSet defines the destination decoded data would be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CodecAccumulator AccumulatorSet non-const reference equal to acc. </dd></dl>

</div>
</div>
<a id="ga029ac12764148d33976f1f5633ba3e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga029ac12764148d33976f1f5633ba3e4e">&#9670;&nbsp;</a></span>decode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename SinglePassRange , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;OutputIterator&gt;::value, OutputIterator&gt;::type nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Defines the range to be processed by decoder. </td></tr>
    <tr><td class="paramname">out</td><td>Defines the beginning of destination range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CodecAccumulator AccumulatorSet non-const reference equal to acc. </dd></dl>

</div>
</div>
<a id="ga9b380b63793f8b569d9b993763ddfe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b380b63793f8b569d9b993763ddfe2a">&#9670;&nbsp;</a></span>decode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt;<a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt;CodecAccumulator&gt; &gt; nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Must meet the requirements of InputIterator. </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator defines the beginning of the range to be decoded. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator defines the end of the range to be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decoded data emplaced in any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </dd></dl>

</div>
</div>
<a id="ga10ff91e4a363478d87dc7744dc1f3756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ff91e4a363478d87dc7744dc1f3756">&#9670;&nbsp;</a></span>decode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Decoder::stream_decoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;boost::accumulators::detail::is_accumulator_set&lt;CodecAccumulator&gt;::value, CodecAccumulator&gt;::type&amp; nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CodecAccumulator &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by rng and inserts the result to destination range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Must meet the requirements of OutputIterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Defines the range to be processed by decoder. </td></tr>
    <tr><td class="paramname">acc</td><td>AccumulatorSet defines the destination decoded data would be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element inserted. </dd></dl>

</div>
</div>
<a id="gafd05c728507aab1602959b4975b09764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd05c728507aab1602959b4975b09764">&#9670;&nbsp;</a></span>decode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Decoder , typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;OutputIterator&gt;::value, OutputIterator&gt;::type nil::crypto3::decode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the elements with particular codec defined with Decoder in the range, defined by [first, last), and inserts the result to another range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Decoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Must meet the requirements of InputIterator. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Must meet the requirements of OutputIterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator defines the beginning of the range to be decoded. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator defines the end of the range to be decoded. </td></tr>
    <tr><td class="paramname">out</td><td>Iterator defines the beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element inserted. </dd></dl>

</div>
</div>
<a id="gaa731755d2bec7fd2dc9c33f5648b8a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa731755d2bec7fd2dc9c33f5648b8a5c">&#9670;&nbsp;</a></span>encode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt;<a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt;CodecAccumulator&gt; &gt; nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by rng and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Defines the range to be processed by encoder.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encoded data emplaced in any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </dd></dl>

</div>
</div>
<a id="ga753e9fac08375391143e153b68cc86cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753e9fac08375391143e153b68cc86cd">&#9670;&nbsp;</a></span>encode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename SinglePassRange , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;boost::accumulators::detail::is_accumulator_set&lt;CodecAccumulator&gt;::value, CodecAccumulator&gt;::type&amp; nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CodecAccumulator &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Defines the range to be processed by encoder. </td></tr>
    <tr><td class="paramname">acc</td><td>AccumulatorSet defines the destination encoded data would be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CodecAccumulator AccumulatorSet non-const reference equal to acc. </dd></dl>

</div>
</div>
<a id="gadc52aa495b9ffc48fa969d4059eb2229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc52aa495b9ffc48fa969d4059eb2229">&#9670;&nbsp;</a></span>encode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename SinglePassRange , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;OutputIterator&gt;::value, OutputIterator&gt;::type nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">const SinglePassRange &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by rng and inserts the result to destination range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">SinglePassRange</td><td>Must meet the requirements of SinglePassRange </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Must meet the requirements of OutputIterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>Defines the range to be processed by encoder. </td></tr>
    <tr><td class="paramname">out</td><td>Defines the beginning of destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element inserted. </dd></dl>

</div>
</div>
<a id="gaca6eac88a0bbb2b6965918a491540eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca6eac88a0bbb2b6965918a491540eb4">&#9670;&nbsp;</a></span>encode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d66/structnil_1_1crypto3_1_1codec_1_1detail_1_1range__codec__impl.html">codec::detail::range_codec_impl</a>&lt;<a class="el" href="../../d6/d9c/structnil_1_1crypto3_1_1codec_1_1detail_1_1value__codec__impl.html">codec::detail::value_codec_impl</a>&lt;CodecAccumulator&gt; &gt; nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Must meet the requirements of InputIterator. </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator defines the beginning of the range to be encoded. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator defines the end of the range to be encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encoded data emplaced in any type convertible to the type satisfying SequenceContainer with the value type satisfying Integral concept requirements. </dd></dl>

</div>
</div>
<a id="gaa4e74d24b6641215095b9c8409c99361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e74d24b6641215095b9c8409c99361">&#9670;&nbsp;</a></span>encode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename InputIterator , typename CodecAccumulator  = typename codec::accumulator_set&lt;typename Encoder::stream_encoder_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;boost::accumulators::detail::is_accumulator_set&lt;CodecAccumulator&gt;::value, CodecAccumulator&gt;::type&amp; nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CodecAccumulator &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last) and returns the result with type satisfying AccumulatorSet requirements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Must meet the requirements of InputIterator. </td></tr>
    <tr><td class="paramname">CodecAccumulator</td><td>Must meet the requirements of AccumulatorSet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator defines the beginning of the range to be encoded. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator defines the end of the range to be encoded. </td></tr>
    <tr><td class="paramname">acc</td><td>AccumulatorSet defines the place encoded data would be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CodecAccumulator AccumulatorSet non-const reference equal to acc. </dd></dl>

</div>
</div>
<a id="gad8327c5f73064ccefe2f1bbc7abe5e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8327c5f73064ccefe2f1bbc7abe5e9e">&#9670;&nbsp;</a></span>encode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Encoder , typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="../../d6/d83/structnil_1_1crypto3_1_1detail_1_1is__iterator.html">detail::is_iterator</a>&lt;OutputIterator&gt;::value, OutputIterator&gt;::type nil::crypto3::encode </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the elements with particular codec defined with Encoder in the range, defined by [first, last), and inserts the result to another range beginning at out. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Encoder</td><td>Must meet the requirements of Codec which determines the particular algorithm to be used with range given. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>Must meet the requirements of InputIterator. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>Must meet the requirements of OutputIterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator defines the beginning of the range to be encoded. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator defines the end of the range to be encoded. </td></tr>
    <tr><td class="paramname">out</td><td>Iterator defines the beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element inserted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/>
<address class="footer"><!--<small>
Generated on Tue Feb 11 2020 13:11:44 for =nil;&nbsp;Foundation&nbsp;Cryptography&nbsp;Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small>--></address>
</body>
<script type="text/javascript" src="../../doxy_boot.js"></script>
</html>
